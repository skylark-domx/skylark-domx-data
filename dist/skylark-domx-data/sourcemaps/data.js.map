{"version":3,"sources":["data.js"],"names":["define","skylark","langx","finder","noder","map","Array","prototype","camelCase","filter","deserializeValue","capitalRE","propMap","tabindex","readonly","for","class","maxlength","cellspacing","cellpadding","rowspan","colspan","usemap","frameborder","contenteditable","valHooks","option","get","elem","val","getAttribute","text","match","join","select","options","index","selectedIndex","one","type","values","max","length","i","selected","disabled","parentNode","nodeName","value","push","set","optionSet","makeArray","inArray","attr","elm","name","undefined","attrName","setAttribute","this","_store","confirm","store","each","attributes","indexOf","replace","_setData","data","dataAttrName","_getData","camelName","toLowerCase","isString","cleanData","txt","textContent","innerText","hooks","ret","isArray","value1","datax","checked","pseudos","dataName","mixin","aria","pluck","nodes","property","call","prop","propName","removeAttr","split","forEach","removeAttribute","removeData","names","removeProp","attach"],"mappings":"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","file":"../data.js","sourcesContent":["define([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-finder\",\r\n    \"skylark-domx-noder\"\r\n], function(skylark, langx, finder,noder) {\r\n    var map = Array.prototype.map,\r\n        filter = Array.prototype.filter,\r\n        camelCase = langx.camelCase,\r\n        deserializeValue = langx.deserializeValue,\r\n\r\n        capitalRE = /([A-Z])/g,\r\n        propMap = {\r\n            'tabindex': 'tabIndex',\r\n            'readonly': 'readOnly',\r\n            'for': 'htmlFor',\r\n            'class': 'className',\r\n            'maxlength': 'maxLength',\r\n            'cellspacing': 'cellSpacing',\r\n            'cellpadding': 'cellPadding',\r\n            'rowspan': 'rowSpan',\r\n            'colspan': 'colSpan',\r\n            'usemap': 'useMap',\r\n            'frameborder': 'frameBorder',\r\n            'contenteditable': 'contentEditable'\r\n        };\r\n\r\n    // Strip and collapse whitespace according to HTML spec\r\n    function stripAndCollapse( value ) {\r\n      var tokens = value.match( /[^\\x20\\t\\r\\n\\f]+/g ) || [];\r\n      return tokens.join( \" \" );\r\n    }\r\n\r\n\r\n    var valHooks = {\r\n      option: {\r\n        get: function( elem ) {\r\n          var val = elem.getAttribute( \"value\" );\r\n          return val != null ?  val :  stripAndCollapse(text( elem ) );\r\n        }\r\n      },\r\n      select: {\r\n        get: function( elem ) {\r\n          var value, option, i,\r\n            options = elem.options,\r\n            index = elem.selectedIndex,\r\n            one = elem.type === \"select-one\",\r\n            values = one ? null : [],\r\n            max = one ? index + 1 : options.length;\r\n\r\n          if ( index < 0 ) {\r\n            i = max;\r\n\r\n          } else {\r\n            i = one ? index : 0;\r\n          }\r\n\r\n          // Loop through all the selected options\r\n          for ( ; i < max; i++ ) {\r\n            option = options[ i ];\r\n\r\n            if ( option.selected &&\r\n\r\n                // Don't return options that are disabled or in a disabled optgroup\r\n                !option.disabled &&\r\n                ( !option.parentNode.disabled ||\r\n                  !noder.nodeName( option.parentNode, \"optgroup\" ) ) ) {\r\n\r\n              // Get the specific value for the option\r\n              value = val(option);\r\n\r\n              // We don't need an array for one selects\r\n              if ( one ) {\r\n                return value;\r\n              }\r\n\r\n              // Multi-Selects return an array\r\n              values.push( value );\r\n            }\r\n          }\r\n\r\n          return values;\r\n        },\r\n\r\n        set: function( elem, value ) {\r\n          var optionSet, option,\r\n            options = elem.options,\r\n            values = langx.makeArray( value ),\r\n            i = options.length;\r\n\r\n          while ( i-- ) {\r\n            option = options[ i ];\r\n\r\n            /* eslint-disable no-cond-assign */\r\n\r\n            if ( option.selected =\r\n              langx.inArray( valHooks.option.get( option ), values ) > -1\r\n            ) {\r\n              optionSet = true;\r\n            }\r\n\r\n            /* eslint-enable no-cond-assign */\r\n          }\r\n\r\n          // Force browsers to behave consistently when non-matching value is set\r\n          if ( !optionSet ) {\r\n            elem.selectedIndex = -1;\r\n          }\r\n          return values;\r\n        }\r\n      }\r\n    };\r\n\r\n\r\n    // Radios and checkboxes getter/setter\r\n    langx.each( [ \"radio\", \"checkbox\" ], function() {\r\n      valHooks[ this ] = {\r\n        set: function( elem, value ) {\r\n          if ( langx.isArray( value ) ) {\r\n            return ( elem.checked = langx.inArray( val(elem), value ) > -1 );\r\n          }\r\n        }\r\n      };\r\n    });\r\n\r\n\r\n\r\n    /*\r\n     * Set property values\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n\r\n    function setAttribute(elm, name, value) {\r\n        if (value == null) {\r\n            elm.removeAttribute(name);\r\n        } else {\r\n            elm.setAttribute(name, value);\r\n        }\r\n    }\r\n\r\n    function aria(elm, name, value) {\r\n        return this.attr(elm, \"aria-\" + name, value);\r\n    }\r\n\r\n    /*\r\n     * Set property values\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n\r\n    function attr(elm, name, value) {\r\n        if (value === undefined) {\r\n            if (typeof name === \"object\") {\r\n                for (var attrName in name) {\r\n                    attr(elm, attrName, name[attrName]);\r\n                }\r\n                return this;\r\n            } else {\r\n                return elm.getAttribute ? elm.getAttribute(name) : elm[name];\r\n            }\r\n        } else {\r\n            elm.setAttribute ? elm.setAttribute(name, value) : elm[name] = value;\r\n            return this;\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     *  Read all \"data-*\" attributes from a node\r\n     * @param {Object} elm  \r\n     */\r\n\r\n    function _attributeData(elm) {\r\n        var store = {}\r\n        langx.each(elm.attributes || [], function(i, attr) {\r\n            if (attr.name.indexOf('data-') == 0) {\r\n                store[camelCase(attr.name.replace('data-', ''))] = deserializeValue(attr.value);\r\n            }\r\n        })\r\n        return store;\r\n    }\r\n\r\n    function _store(elm, confirm) {\r\n        var store = elm[\"_$_store\"];\r\n        if (!store && confirm) {\r\n            store = elm[\"_$_store\"] = _attributeData(elm);\r\n        }\r\n        return store;\r\n    }\r\n\r\n    function _getData(elm, name) {\r\n        if (name === undefined) {\r\n            return _store(elm, true);\r\n        } else {\r\n            var store = _store(elm);\r\n            if (store) {\r\n                if (name in store) {\r\n                    return store[name];\r\n                }\r\n                var camelName = camelCase(name);\r\n                if (camelName in store) {\r\n                    return store[camelName];\r\n                }\r\n            }\r\n            var attrName = 'data-' + name.replace(capitalRE, \"-$1\").toLowerCase()\r\n            var value = attr(elm, attrName);\r\n            if (!langx.isString(value)) {\r\n              value = undefined;\r\n            }\r\n            return value;\r\n        }\r\n\r\n    }\r\n\r\n    function _setData(elm, name, value) {\r\n        var store = _store(elm, true);\r\n        store[camelCase(name)] = value;\r\n    }\r\n\r\n\r\n    /*\r\n     * xxx\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n    function data(elm, name, value) {\r\n\r\n        if (value === undefined) {\r\n            if (typeof name === \"object\") {\r\n                for (var dataAttrName in name) {\r\n                    _setData(elm, dataAttrName, name[dataAttrName]);\r\n                }\r\n                return this;\r\n            } else {\r\n                return _getData(elm, name);\r\n            }\r\n        } else {\r\n            _setData(elm, name, value);\r\n            return this;\r\n        }\r\n    } \r\n    /*\r\n     * Remove from the element all items that have not yet been run. \r\n     * @param {Object} elm  \r\n     */\r\n\r\n    function cleanData(elm) {\r\n        if (elm[\"_$_store\"]) {\r\n            delete elm[\"_$_store\"];\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Remove a previously-stored piece of data. \r\n     * @param {Object} elm  \r\n     * @param {Array} names\r\n     */\r\n    function removeData(elm, names) {\r\n        if (names) {\r\n            if (langx.isString(names)) {\r\n                names = names.split(/\\s+/);\r\n            }\r\n            var store = _store(elm, true);\r\n            names.forEach(function(name) {\r\n                delete store[name];\r\n                delete store[camelCase(name)];\r\n            });            \r\n        } else {\r\n            cleanData(elm);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * xxx \r\n     * @param {Object} elm  \r\n     * @param {Array} names\r\n     */\r\n    function pluck(nodes, property) {\r\n        return map.call(nodes, function(elm) {\r\n            return elm[property];\r\n        });\r\n    }\r\n\r\n    /*\r\n     * Get or set the value of an property for the specified element.\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     * @param {String} value\r\n     */\r\n    function prop(elm, name, value) {\r\n      if (value === undefined) {\r\n          if (typeof name === \"object\") {\r\n              for (var propName in name) {\r\n                  prop(elm, propName, name[propName]);\r\n              }\r\n              return this;\r\n          } \r\n      } \r\n\r\n\r\n      name = propMap[name] || name;\r\n      if (value === undefined) {\r\n          return elm[name];\r\n      } else {\r\n          elm[name] = value;\r\n          return this;\r\n      }\r\n    }\r\n\r\n    /*\r\n     * remove Attributes  \r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     */\r\n    function removeAttr(elm, name) {\r\n        name.split(' ').forEach(function(attr) {\r\n            setAttribute(elm, attr);\r\n        });\r\n        return this;\r\n    }\r\n\r\n\r\n    /*\r\n     * Remove the value of a property for the first element in the set of matched elements or set one or more properties for every matched element.\r\n     * @param {Object} elm  \r\n     * @param {String} name\r\n     */\r\n    function removeProp(elm, name) {\r\n        name.split(' ').forEach(function(prop) {\r\n            delete elm[prop];\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /*   \r\n     * Get the combined text contents of each element in the set of matched elements, including their descendants, or set the text contents of the matched elements.  \r\n     * @param {Object} elm  \r\n     * @param {String} txt\r\n     */\r\n    function text(elm, txt) {\r\n        if (txt === undefined) {\r\n            return elm.textContent !==undefined  ? elm.textContent : elm.innerText;\r\n        } else {\r\n            txt = txt == null ? '' : '' + txt ;\r\n            if (elm.textContent !==undefined ) {\r\n              elm.textContent = txt ;\r\n            } else {\r\n              elm.innerText = txt ;\r\n            }\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /*   \r\n     * Get the current value of the first element in the set of matched elements or set the value of every matched element.\r\n     * @param {Object} elm  \r\n     * @param {String} value\r\n     */\r\n    function val(elm, value) {\r\n        var hooks = valHooks[ elm.type ] || valHooks[ elm.nodeName.toLowerCase() ];\r\n        if (value === undefined) {\r\n/*\r\n            if (elm.multiple) {\r\n                // select multiple values\r\n                var selectedOptions = filter.call(finder.find(elm, \"option\"), (function(option) {\r\n                    return option.selected;\r\n                }));\r\n                return pluck(selectedOptions, \"value\");\r\n            } else {\r\n                if (/input|textarea/i.test(elm.tagName)) {\r\n                  return elm.value;\r\n                }\r\n                return text(elm);\r\n            }\r\n*/\r\n\r\n          if ( hooks &&  \"get\" in hooks &&  ( ret = hooks.get( elm, \"value\" ) ) !== undefined ) {\r\n            return ret;\r\n          }\r\n\r\n          ret = elm.value;\r\n\r\n          // Handle most common string cases\r\n          if ( typeof ret === \"string\" ) {\r\n            return ret.replace( /\\r/g, \"\" );\r\n          }\r\n\r\n          // Handle cases where value is null/undef or number\r\n          return ret == null ? \"\" : ret;\r\n\r\n        } else {\r\n/*          \r\n            if (/input|textarea/i.test(elm.tagName)) {\r\n              elm.value = value;\r\n            } else {\r\n              text(elm,value);\r\n            }\r\n            return this;\r\n*/\r\n          // Treat null/undefined as \"\"; convert numbers to string\r\n          if ( value == null ) {\r\n            value = \"\";\r\n\r\n          } else if ( typeof value === \"number\" ) {\r\n            value += \"\";\r\n\r\n          } else if ( langx.isArray( value ) ) {\r\n            value = langx.map( value, function( value1 ) {\r\n              return value1 == null ? \"\" : value1 + \"\";\r\n            } );\r\n          }\r\n\r\n          // If set returns undefined, fall back to normal setting\r\n          if ( !hooks || !( \"set\" in hooks ) || hooks.set( elm, value, \"value\" ) === undefined ) {\r\n            elm.value = value;\r\n          }\r\n        }      \r\n    }\r\n\r\n\r\n    finder.pseudos.data = function( elem, i, match,dataName ) {\r\n        return !!data( elem, dataName || match[3]);\r\n    };\r\n   \r\n\r\n    function datax() {\r\n        return datax;\r\n    }\r\n\r\n    langx.mixin(datax, {\r\n        aria: aria,\r\n\r\n        attr: attr,\r\n\r\n        cleanData: cleanData,\r\n\r\n        data: data,\r\n\r\n        pluck: pluck,\r\n\r\n        prop: prop,\r\n\r\n        removeAttr: removeAttr,\r\n\r\n        removeData: removeData,\r\n\r\n        removeProp: removeProp,\r\n\r\n        text: text,\r\n\r\n        val: val,\r\n\r\n        valHooks : valHooks\r\n    });\r\n\r\n    return skylark.attach(\"domx.data\", datax);\r\n});"]}